<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web IFC Viewer - HITL Review</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
        }

        #three-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* å·¦ä¸Šè§’æ§åˆ¶åŒº */
        #controls-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.15);
            z-index: 2;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* HITL é¢æ¿ (é»˜è®¤éšè—) */
        #hitl-panel {
            display: none;
            flex-direction: column;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        /* å³ä¾§å±æ€§é¢æ¿ */
        #property-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            bottom: 20px;
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: -2px 0 15px rgba(0, 0, 0, 0.1);
            z-index: 2;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        #property-header {
            padding: 15px;
            background: #0078d4;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #property-content {
            padding: 15px;
            overflow-y: auto;
            flex: 1;
            font-size: 13px;
        }

        /* è¡¨æ ¼æ ·å¼ */
        .prop-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .prop-table td {
            padding: 6px;
            border-bottom: 1px solid #eee;
            word-break: break-word;
        }

        .prop-key {
            font-weight: bold;
            color: #555;
            width: 40%;
        }

        .group-title {
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 5px;
            color: #0078d4;
            border-bottom: 2px solid #eee;
            padding-bottom: 3px;
        }

        /* UI å…ƒç´  */
        h1,
        h2 {
            margin: 0 0 10px 0;
            color: #333;
        }

        h1 {
            font-size: 20px;
        }

        h2 {
            font-size: 16px;
            margin-top: 10px;
            color: #0078d4;
        }

        label {
            font-size: 13px;
            font-weight: bold;
            display: block;
            margin-top: 10px;
        }

        input[type="file"] {
            display: block;
            width: 100%;
            font-size: 12px;
            margin-bottom: 5px;
        }

        select,
        button {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: inherit;
        }

        button {
            cursor: pointer;
            background-color: #f0f0f0;
            transition: background 0.2s;
        }

        button:hover {
            background-color: #e0e0e0;
        }

        button.primary-btn {
            background-color: #0078d4;
            color: white;
            border: none;
            font-weight: bold;
        }

        button.primary-btn:hover {
            background-color: #005a9e;
        }

        .tips {
            font-size: 12px;
            color: #666;
            line-height: 1.6;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .review-info {
            background: #fff8e1;
            padding: 10px;
            border: 1px solid #ffe0b2;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 10px;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10;
            flex-direction: column;
            color: #333;
            font-weight: bold;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0078d4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        button.close-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
            width: auto;
            padding: 0;
            margin: 0;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "three/examples/jsm/": "https://unpkg.com/three@0.155.0/examples/jsm/",
                "web-ifc-three": "https://unpkg.com/web-ifc-three@0.0.126/IFCLoader.js",
                "web-ifc": "https://unpkg.com/web-ifc@0.0.44/web-ifc-api.js" 
            }
        }
    </script>
</head>

<body>

    <div id="controls-container">
        <h1>ğŸ—ï¸ Web IFC æŸ¥çœ‹å™¨ </h1>

        <label>1. åŠ è½½ IFC æ¨¡å‹:</label>
        <input type="file" id="file-input" accept=".ifc">

        <label>2. åŠ è½½ Review æ•°æ® (JSON):</label>
        <input type="file" id="json-input" accept=".json" disabled>

        <div class="tips" style="margin-top: 10px;">
            <strong>å¸¸è§„æ“ä½œ:</strong><br>
            ğŸ–±ï¸ å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾<br>
            ğŸ‘† åŒå‡»æ„ä»¶æŸ¥çœ‹å±æ€§
        </div>

        <!-- HITL äº¤äº’é¢æ¿ -->
        <div id="hitl-panel">
            <h2>ğŸ” äººå·¥å®¡æ ¸ (HITL)</h2>
            <div id="review-status" style="margin-bottom:10px; font-weight:bold;">0 / 0</div>

            <div class="review-info" id="review-details">
                ç­‰å¾…æ•°æ®åŠ è½½...
            </div>

            <label for="category-select">ç¡®è®¤åˆ†ç±» (Mapping):</label>
            <select id="category-select"></select>

            <div class="nav-buttons">
                <button id="next-btn" class="primary-btn">ç¡®è®¤ & ä¸‹ä¸€ä¸ª</button>
            </div>

            <button id="export-btn" style="margin-top: 20px; background: #4caf50; color: white;">ğŸ’¾ å¯¼å‡ºç»“æœ JSON</button>
        </div>
    </div>

    <div id="property-panel">
        <div id="property-header">
            <span>æ„ä»¶å±æ€§</span>
            <button class="close-btn"
                onclick="document.getElementById('property-panel').style.display='none'">âœ•</button>
        </div>
        <div id="property-content">ç‚¹å‡»æ„ä»¶æŸ¥çœ‹è¯¦æƒ…...</div>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">æ­£åœ¨è§£æ IFC æ¨¡å‹...</div>
    </div>

    <canvas id="three-canvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { IFCLoader } from 'web-ifc-three';

        // --- å˜é‡å®šä¹‰ ---
        let ifcModel = null;
        let reviewData = null;
        let reviewQueue = [];
        let currentIndex = -1;
        let guidToExpressIdMap = new Map();

        const canvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe8e8e8);

        // --- 1. åŸºç¡€åœºæ™¯åˆå§‹åŒ– ---
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight2.position.set(-10, -10, -5);
        scene.add(dirLight2);

        // è¾…åŠ©çº¿
        const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0xbbbbbb);
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;

        // --- 2. IFC Loader ---
        const ifcLoader = new IFCLoader();
        // è¿™é‡Œçš„è·¯å¾„éœ€è¦ç¡®ä¿æ­£ç¡®ï¼Œé€šå¸¸æŒ‡å‘ wasm æ–‡ä»¶æ‰€åœ¨ç›®å½•
        ifcLoader.ifcManager.setWasmPath('https://unpkg.com/web-ifc@0.0.44/');

        // é«˜äº®æè´¨
        const highlightMaterial = new THREE.MeshLambertMaterial({
            transparent: true,
            opacity: 0.8,
            color: 0xff0000, // HITL æ¨¡å¼çº¢è‰²
            depthTest: false
        });

        const selectMaterial = new THREE.MeshLambertMaterial({
            transparent: true,
            opacity: 0.6,
            color: 0xffcc00, // æ™®é€šé€‰æ‹©é»„è‰²
            depthTest: false
        });

        // --- 3. æ ¸å¿ƒåŠŸèƒ½: Raycasting ---
        const raycaster = new THREE.Raycaster();
        raycaster.firstHitOnly = true;
        const mouse = new THREE.Vector2();

        window.ondblclick = (event) => {
            if (!ifcModel) return;
            const bounds = canvas.getBoundingClientRect();
            const x1 = event.clientX - bounds.left;
            const y1 = event.clientY - bounds.top;
            mouse.x = (x1 / bounds.width) * 2 - 1;
            mouse.y = -(y1 / bounds.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const found = raycaster.intersectObjects([ifcModel])[0];

            if (found) {
                const index = found.faceIndex;
                const geometry = found.object.geometry;
                const id = ifcLoader.ifcManager.getExpressId(geometry, index);
                highlightItem(id, selectMaterial);
                displayProperties(id);
            } else {
                clearHighlight(selectMaterial);
                document.getElementById('property-panel').style.display = 'none';
            }
        };

        // --- 4. HITL é€»è¾‘ ---
        const jsonInput = document.getElementById('json-input');
        const hitlPanel = document.getElementById('hitl-panel');
        const statusDiv = document.getElementById('review-status');
        const detailsDiv = document.getElementById('review-details');
        const categorySelect = document.getElementById('category-select');
        const nextBtn = document.getElementById('next-btn');
        const exportBtn = document.getElementById('export-btn');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');

        jsonInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    reviewData = JSON.parse(e.target.result);
                    initReviewProcess();
                } catch (err) {
                    alert("JSON è§£æå¤±è´¥: " + err);
                }
            };
            reader.readAsText(file);
        });

        async function initReviewProcess() {
            if (!ifcModel) {
                alert("è¯·å…ˆåŠ è½½ IFC æ¨¡å‹ï¼");
                return;
            }

            loadingOverlay.style.display = 'flex';
            loadingText.innerText = 'æ­£åœ¨å»ºç«‹ GUID æ˜ å°„ (éå†ç©ºé—´ç»“æ„)...';

            // 1. å»ºç«‹ GUID -> ExpressID æ˜ å°„
            await buildGuidMap();

            loadingOverlay.style.display = 'none';

            // 2. å¡«å……ä¸‹æ‹‰æ¡†
            categorySelect.innerHTML = '';
            if (reviewData.meta && reviewData.meta.all_categories) {
                reviewData.meta.all_categories.forEach(cat => {
                    const opt = document.createElement('option');
                    opt.value = cat;
                    opt.innerText = cat;
                    categorySelect.appendChild(opt);
                });
                const unknownOpt = document.createElement('option');
                unknownOpt.value = "UNKNOWN";
                unknownOpt.innerText = "UNKNOWN";
                categorySelect.appendChild(unknownOpt);
            }

            // 3. ç­›é€‰éœ€è¦å®¡æ ¸çš„é¡¹
            reviewQueue = reviewData.results.filter(item => item.status === "NEEDS_REVIEW");

            if (reviewQueue.length === 0) {
                alert("JSON ä¸­æ²¡æœ‰çŠ¶æ€ä¸º NEEDS_REVIEW çš„æ„ä»¶ã€‚");
                hitlPanel.style.display = 'none';
                return;
            }

            // 4. å¼€å§‹ç¬¬ä¸€é¡¹
            hitlPanel.style.display = 'flex';
            currentIndex = 0;

            // å…³é”®ï¼šè°ƒç”¨ loadReviewItem
            loadReviewItem(currentIndex);
        }

        // --- æ ¸å¿ƒï¼šé€šè¿‡éå†ç©ºé—´ç»“æ„å»ºç«‹ GUID æ˜ å°„ ---
        async function buildGuidMap() {
            guidToExpressIdMap.clear();
            const modelID = ifcModel.modelID;

            console.log("å¼€å§‹å»ºç«‹ GUID æ˜ å°„...");

            try {
                // è·å–ç©ºé—´ç»“æ„æ ‘
                const rootNode = await ifcLoader.ifcManager.getSpatialStructure(modelID);
                const allIds = [];

                // é€’å½’æ”¶é›†æ‰€æœ‰ ID
                function traverse(node) {
                    if (node.expressID !== undefined) {
                        allIds.push(node.expressID);
                    }
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => traverse(child));
                    }
                }

                if (rootNode && rootNode.expressID) {
                    traverse(rootNode);
                }

                console.log(`é€šè¿‡ç©ºé—´ç»“æ„æ‰¾åˆ°äº† ${allIds.length} ä¸ªæ„ä»¶ã€‚å¼€å§‹è¯»å–å±æ€§...`);

                let matchCount = 0;
                for (let i = 0; i < allIds.length; i++) {
                    const id = allIds[i];
                    try {
                        const props = await ifcLoader.ifcManager.getItemProperties(modelID, id);
                        if (props && props.GlobalId) {
                            let guidVal = props.GlobalId.value || props.GlobalId;
                            guidToExpressIdMap.set(guidVal, id);
                            matchCount++;
                            // è°ƒè¯•æ—¥å¿—
                            if (matchCount <= 3) console.log(`[è°ƒè¯•] æå–åˆ°æ¨¡å‹å†…éƒ¨ GUID: ${guidVal}`);
                        }
                    } catch (e) { }
                }

                console.log(`æ˜ å°„å®Œæˆã€‚å…±ç´¢å¼•äº† ${guidToExpressIdMap.size} ä¸ªæ„ä»¶çš„ GUIDã€‚`);

            } catch (err) {
                console.error("å»ºç«‹æ˜ å°„æ—¶å‡ºé”™:", err);
                alert("å»ºç«‹æ¨¡å‹ç´¢å¼•å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æŠ¥é”™ã€‚");
            }
        }

        // --- æ ¸å¿ƒï¼šåŠ è½½å®¡æ ¸é¡¹ (æ­¤å‰ä¸¢å¤±çš„å‡½æ•°) ---
        async function loadReviewItem(index) {
            if (index < 0 || index >= reviewQueue.length) {
                detailsDiv.innerHTML = "<strong>ğŸ‰ å®¡æ ¸å®Œæˆï¼è¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯¼å‡ºã€‚</strong>";
                nextBtn.disabled = true;
                categorySelect.disabled = true;
                clearHighlight(highlightMaterial);
                return;
            }

            const item = reviewQueue[index];
            statusDiv.innerText = `è¿›åº¦: ${index + 1} / ${reviewQueue.length}`;

            detailsDiv.innerHTML = `
                <div style="margin-bottom:4px;"><strong>Name:</strong> ${item.name}</div>
                <div style="margin-bottom:4px;"><strong>GUID:</strong> <span style="font-size:11px; color:#555;">${item.guid}</span></div>
                <div style="margin-bottom:4px;"><strong>Category:</strong> ${item.category}</div>
                <div style="margin-bottom:4px;"><strong>Confidence:</strong> ${item.confidence}</div>
                <div style="margin-bottom:4px;"><strong>Current Status:</strong> ${item.status}</div>
                <div><strong>Reasoning:</strong> <span style="color:#666; font-style:italic;">${item.reasoning}</span></div>
            `;

            categorySelect.value = item.category || "GENERIC_ELEMENT";

            // æŸ¥æ‰¾å¯¹åº”çš„ ExpressID
            const expressID = guidToExpressIdMap.get(item.guid);

            if (expressID) {
                console.log(`Found item ${item.guid} -> ID: ${expressID}`);
                highlightItem(expressID, highlightMaterial);
                focusCameraOnItem(expressID);
                displayProperties(expressID);
            } else {
                console.warn(`GUID ${item.guid} not found in model.`);
                clearHighlight(highlightMaterial);
                // å¼¹çª—è­¦å‘Šæ”¹ä¸º Console è­¦å‘Šï¼Œé¿å…æ‰“æ–­æ“ä½œ
                detailsDiv.innerHTML += `<br><strong style="color:red;">âš ï¸ è­¦å‘Š: æ¨¡å‹ä¸­æœªæ‰¾åˆ°æ­¤ GUIDï¼Œæ— æ³•é«˜äº®ã€‚</strong>`;
            }
        }

        // ä¸‹ä¸€æ­¥æŒ‰é’®
        nextBtn.addEventListener('click', () => {
            if (currentIndex >= 0 && currentIndex < reviewQueue.length) {
                const item = reviewQueue[currentIndex];
                const selectedCategory = categorySelect.value;

                // æ›´æ–°æ•°æ®
                item.category = selectedCategory;
                item.status = "HUMAN_VERIFIED";

                // æ›´æ–°åŸå§‹æ•°æ®
                const originalItem = reviewData.results.find(r => r.guid === item.guid);
                if (originalItem) {
                    originalItem.category = selectedCategory;
                    originalItem.status = "HUMAN_VERIFIED";
                }

                currentIndex++;
                loadReviewItem(currentIndex);
            }
        });

        // å¯¼å‡ºæŒ‰é’®
        exportBtn.addEventListener('click', () => {
            if (!reviewData) return;
            const str = JSON.stringify(reviewData, null, 2);
            const blob = new Blob([str], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hitl_data_verified.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // --- è¾…åŠ©åŠŸèƒ½ ---

        function highlightItem(expressID, material) {
            if (!ifcModel) return;
            try {
                ifcLoader.ifcManager.createSubset({
                    modelID: ifcModel.modelID,
                    ids: [expressID],
                    material: material,
                    scene: scene,
                    removePrevious: true
                });
            } catch (e) {
                console.error("é«˜äº®å¤±è´¥:", e);
            }
        }

        function clearHighlight(material) {
            if (!ifcModel) return;
            ifcLoader.ifcManager.removeSubset(ifcModel.modelID, scene, material);
        }

        async function focusCameraOnItem(expressID) {
            try {
                const subset = ifcLoader.ifcManager.createSubset({
                    modelID: ifcModel.modelID,
                    ids: [expressID],
                    scene: scene,
                    removePrevious: true,
                    material: highlightMaterial
                });

                if (subset && subset.geometry) {
                    subset.geometry.computeBoundingBox();
                    const box = subset.geometry.boundingBox;
                    if (box) {
                        const center = new THREE.Vector3();
                        box.getCenter(center);

                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);
                        // é¿å… maxDim ä¸º 0 (ä¾‹å¦‚ç©ºå‡ ä½•ä½“)
                        const fov = camera.fov * (Math.PI / 180);
                        let cameraZ = Math.abs((maxDim || 5) / 2 / Math.tan(fov / 2));
                        cameraZ *= 2.5;

                        const newPos = center.clone().add(new THREE.Vector3(cameraZ, cameraZ, cameraZ));
                        camera.position.copy(newPos);
                        camera.lookAt(center);
                        controls.target.copy(center);
                        controls.update();
                    }
                }
            } catch (e) {
                console.warn("æ— æ³•èšç„¦:", e);
            }
        }

        async function displayProperties(id) {
            const propPanel = document.getElementById('property-panel');
            const propContent = document.getElementById('property-content');

            propPanel.style.display = 'flex';
            propContent.innerHTML = 'Loading properties...';

            try {
                const modelID = ifcModel.modelID;
                const props = await ifcLoader.ifcManager.getItemProperties(modelID, id);
                const psets = await ifcLoader.ifcManager.getPropertySets(modelID, id);

                let html = `<div class="group-title">åŸºæœ¬ä¿¡æ¯ (Basic)</div>`;
                html += `<table class="prop-table">`;
                html += `<tr><td class="prop-key">ID</td><td class="prop-val">${props.expressID}</td></tr>`;
                html += `<tr><td class="prop-key">GlobalId</td><td class="prop-val">${props.GlobalId ? formatVal(props.GlobalId.value) : '-'}</td></tr>`;
                html += `<tr><td class="prop-key">Name</td><td class="prop-val">${props.Name ? formatVal(props.Name.value) : '-'}</td></tr>`;
                html += `<tr><td class="prop-key">Type</td><td class="prop-val">${formatIFCType(props.constructor.name)}</td></tr>`;
                html += `</table>`;

                for (const pset of psets) {
                    if (pset.HasProperties) {
                        html += `<div class="group-title">${pset.Name ? formatVal(pset.Name.value) : 'PSet'}</div>`;
                        html += `<table class="prop-table">`;
                        for (const propRef of pset.HasProperties) {
                            const prop = await ifcLoader.ifcManager.getItemProperties(modelID, propRef.value);
                            const key = prop.Name ? formatVal(prop.Name.value) : 'Unknown';
                            let val = '-';
                            if (prop.NominalValue) {
                                val = formatVal(prop.NominalValue.value);
                            }
                            html += `<tr><td class="prop-key">${key}</td><td class="prop-val">${val}</td></tr>`;
                        }
                        html += `</table>`;
                    }
                }
                propContent.innerHTML = html;
            } catch (error) {
                console.error(error);
                propContent.innerHTML = "æ— æ³•è¯»å–å±æ€§æ•°æ®";
            }
        }

        function formatVal(val) {
            if (typeof val === 'number') return val.toFixed(3);
            return val;
        }

        function formatIFCType(typeStr) {
            return typeStr.replace('Ifc', '').replace(/([A-Z])/g, ' $1').trim();
        }

        // --- 5. æ–‡ä»¶åŠ è½½é€»è¾‘ ---
        const fileInput = document.getElementById('file-input');

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            loadingOverlay.style.display = 'flex';
            loadingText.innerText = 'æ­£åœ¨è§£æ IFC æ¨¡å‹...';

            if (ifcModel) {
                scene.remove(ifcModel);
                ifcLoader.ifcManager.removeSubset(ifcModel.modelID, scene, highlightMaterial);
                ifcLoader.ifcManager.removeSubset(ifcModel.modelID, scene, selectMaterial);
                ifcModel = null;
            }
            hitlPanel.style.display = 'none';
            document.getElementById('json-input').value = '';
            document.getElementById('json-input').disabled = true;

            const ifcURL = URL.createObjectURL(file);

            ifcLoader.load(ifcURL, (model) => {
                ifcModel = model;
                scene.add(model);
                loadingOverlay.style.display = 'none';

                document.getElementById('json-input').disabled = false;

                if (model.geometry.boundingBox) {
                    const center = new THREE.Vector3();
                    model.geometry.boundingBox.getCenter(center);
                    controls.target.copy(center);
                    camera.position.set(center.x + 20, center.y + 20, center.z + 20);
                }
            });
        });

        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>